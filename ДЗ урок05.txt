Практическое задание по теме «Операторы, фильтрация, сортировка и ограничение»
1. Пусть в таблице users поля created_at и updated_at оказались незаполненными. Заполните их текущими датой и временем.
2. Таблица users была неудачно спроектирована. Записи created_at и updated_at были заданы типом VARCHAR и в них долгое время помещались значения в формате 20.10.2017 8:10. Необходимо преобразовать поля к типу DATETIME, сохранив введённые ранее значения.
3. В таблице складских запасов storehouses_products в поле value могут встречаться самые разные цифры: 0, если товар закончился и выше нуля, если на складе имеются запасы. Необходимо отсортировать записи таким образом, чтобы они выводились в порядке увеличения значения value. Однако нулевые запасы должны выводиться в конце, после всех записей.
4. (по желанию) Из таблицы users необходимо извлечь пользователей, родившихся в августе и мае. Месяцы заданы в виде списка английских названий (may, august)
4. (по желанию) Из таблицы catalogs извлекаются записи при помощи запроса. SELECT * FROM catalogs WHERE id IN (5, 1, 2); Отсортируйте записи в порядке, заданном в списке IN.



--01--

CREATE DATABASE test01;
SHOW DATABASES;
USE test01;

CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) COMMENT 'Имя покупателя',
  birthday_at DATE COMMENT 'Дата рождения',
  created_at DATETIME,
  updated_at DATETIME);
 
  SHOW tables;
  SELECT * FROM users;

INSERT INTO users (name, birthday_at, created_at, updated_at) VALUES
  ('Геннадий', '1990-10-05', NULL, NULL),
  ('Наталья', '1984-11-12', NULL, NULL),
  ('Александр', '1985-05-20', NULL, NULL),
  ('Сергей', '1988-02-14', NULL, NULL),
  ('Иван', '1998-01-12', NULL, NULL),
  ('Мария', '1992-08-29', NULL, NULL);
  
UPDATE 
  users 
SET
  created_at  = CURRENT_TIMESTAMP(),
  updated_at  = NOW();

 SELECT * FROM users;
--------------------------------------------------------------------

--02--

DROP DATABASE test02;
CREATE DATABASE test02;
SHOW DATABASES;
USE test02;

DROP TABLE IF EXISTS users;
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) COMMENT 'Имя покупателя',
  birthday_at DATE COMMENT 'Дата рождения',
  created_at VARCHAR(255),
  updated_at VARCHAR(255));
 
  SHOW tables;
  SELECT * FROM users;

INSERT INTO users (name, birthday_at, created_at, updated_at) 
VALUES
  ('Геннадий', '1990-10-05', '08.05.2010 15.35', '08.05.2010 15.35'),
  ('Наталья', '1984-11-12', '12.07.2012 17.20', '12.07.2012 17.20'),
  ('Александр', '1985-05-20', '15.01.2011 12.00', '15.01.2011 12.00'),
  ('Сергей', '1988-02-14', '21.09.2014 11.22', '21.09.2014 11.22'),
  ('Иван', '1998-01-12', '02.01.2012 22.11', '02.01.2012 22.11'),
  ('Мария', '1992-08-29', '27.12.2010 23.45', '27.12.2010 23.45');
  
UPDATE 
  users 
SET
  created_at  = STR_TO_DATE(created_at, '%d.%m.%Y %k.%i'),
  updated_at  = STR_TO_DATE(updated_at, '%d.%m.%Y %k.%i');
 
ALTER TABLE
  users
CHANGE
  created_at created_at DATETIME DEFAULT CURRENT_TIMESTAMP;

ALTER TABLE
  users
CHANGE
  updated_at updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP;
 
DESCRIBE users;
SELECT * FROM users;
--------------------------------------------------------------------

--03--

DROP DATABASE test03;
CREATE DATABASE test03;
SHOW DATABASES;
USE test03;

DROP TABLE IF EXISTS storehouses_products;
CREATE TABLE storehouses_products (
  id SERIAL PRIMARY KEY,
  storehouse_id INT UNSIGNED,
  product_id INT UNSIGNED,
  value INT UNSIGNED COMMENT 'Запас товарной позиции на складе',
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
  updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
  ) COMMENT = 'Запасы на складе';
  
  INSERT INTO
  	storehouses_products (storehouse_id, product_id, value)
  	VALUES
  	(1, 540, 0),
  	(1, 655, 3655),
  	(1, 2677, 0),
  	(1, 225, 30),
  	(1, 719, 500),
  	(1, 638,1);
  
  SHOW tables;
  SELECT * FROM storehouses_products;
  
  SELECT * FROM storehouses_products
  ORDER BY IF (value > 0, 0, 1), value;
 
 -- Более простой вариант
 SELECT * FROM storehouses_products
 ORDER BY value = 0, value;
 -------------------------------------------------------------------

--04--

DROP DATABASE test04;
CREATE DATABASE test04;
SHOW DATABASES;
USE test04;

DROP TABLE IF EXISTS users;
CREATE TABLE users (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) COMMENT 'Имя пользователя',
  birthday_at DATE COMMENT 'Дата рождения');

 
  SHOW tables;
  SELECT * FROM users;
 INSERT INTO users (name, birthday_at) VALUES
 ('Василий', '1978-05-25'),
 ('Петр', '1979-06-14'),
 ('Иван', '1979-12-16'),
 ('Степан', '1977-08-22'),
 ('Григорий', '1978-05-09'),
 ('Константин', '1980-08-02');
  
SELECT id, name, birthday_at FROM users
WHERE DATE_FORMAT(birthday_at, '%M') IN ('may', 'august'); 

USE vk;
SELECT * FROM profiles;
SELECT user_id, birthday, city FROM profiles
WHERE DATE_FORMAT(birthday, '%M') IN ('may', 'august'); 
--------------------------------------------------------------------

--05--

USE vk;
SELECT * FROM profiles
WHERE user_id IN (5, 1, 2)
ORDER BY FIELD(user_id, 5, 1, 2);
--------------------------------------------------------------------
Практическое задание теме «Агрегация данных»
1. Подсчитайте средний возраст пользователей в таблице users.
2. Подсчитайте количество дней рождения, которые приходятся на каждый из дней недели. Следует учесть, что необходимы дни недели текущего года, а не года рождения.
3. (по желанию) Подсчитайте произведение чисел в столбце таблицы.


--01--

USE vk;
SELECT 
	AVG(TIMESTAMPDIFF(YEAR, birthday, NOW())) AS age 
FROM profiles;
--------------------------------------------------------------------

--02--

USE vk;
SELECT 
	DATE_FORMAT(DATE(CONCAT_WS('-', YEAR(NOW()), MONTH(birthday), DAY(birthday))), '%W') AS day,
	COUNT(*) AS total
FROM profiles GROUP BY day ORDER BY total DESC;
--------------------------------------------------------------------

--03--

USE test04;
SELECT ROUND(EXP(SUM(LN(id)))) FROM users;